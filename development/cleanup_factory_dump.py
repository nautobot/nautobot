#!/usr/bin/env python3
"""
Given a flat JSON list of Nautobot records as generated by `dumpdata`, restructure it into a more useful format.

Specifically, will output a dict of dicts, of the form:

    {
      "contenttypes.contenttype": {
         "1": {<data for PK 1>},
         "2": {<data for PK 1>},
         ...
      },
      "extras.job": {
         "<pk for first record created>": {<data for this record>},
         "<pk for second record created>": {<data for this record>},
         ...
      },
      ...
    }

The intended usage of this format is to be able to run the `generate_test_data` command twice, and compare its outputs
for consistency and reproducibility.

Run as `python3 cleanup_factory_dump.py <input file> <output file>`
"""

import json
import sys

# Approximate order of record creation by the generate_test_data management command.
# Only approximate since some factories are called at multiple points in the command execution.
FACTORY_ORDER = [
    "contenttypes.contenttype",
    "extras.job",
    "extras.role",
    "extras.status",
    "extras.tag",
    "users.user",
    "extras.savedview",
    "extras.contact",
    "extras.team",
    "tenancy.tenantgroup",
    "tenancy.tenant",
    "dcim.locationtype",
    "dcim.location",
    "dcim.controller",
    "dcim.controllermanageddevicegroup",
    "ipam.rir",
    "ipam.routetarget",
    "ipam.namespace",
    "ipam.vrf",
    "ipam.vlangroup",
    "ipam.vlan",
    "ipam.vlanlocationassignment",
    "ipam.prefix",
    "ipam.prefixlocationassignment",
    "ipam.ipaddress",
    "dcim.devicefamily",
    "dcim.manufacturer",
    "dcim.platform",
    "dcim.softwareversion",
    "dcim.softwareimagefile",
    "dcim.devicetype",
    "dcim.devicetypetosoftwareimagefile",
    "dcim.moduletype",
    "dcim.consoleporttemplate",
    "dcim.consoleserverporttemplate",
    "dcim.rearporttemplate",
    "dcim.frontporttemplate",
    "dcim.interfacetemplate",
    "dcim.powerporttemplate",
    "dcim.poweroutlettemplate",
    "dcim.modulebaytemplate",
    "dcim.deviceredundancygroup",
    "dcim.device",
    "dcim.modulebay",
    "dcim.module",
    "dcim.consoleport",
    "dcim.consoleserverport",
    "dcim.rearport",
    "dcim.frontport",
    "dcim.interface",
    "dcim.powerport",
    "dcim.poweroutlet",
    "cloud.cloudaccount",
    "cloud.cloudresourcetype",
    "cloud.cloudnetwork",
    "cloud.cloudnetworkprefixassignment",
    "cloud.cloudservice",
    "cloud.cloudservicenetworkassignment",
    "circuits.circuittype",
    "circuits.provider",
    "circuits.providernetwork",
    "circuits.circuit",
    "circuits.circuittermination",
    "extras.externalintegration",
    "extras.dynamicgroup",
    "extras.staticgroupassociation",
    "extras.metadatatype",
    "extras.metadatachoice",
    "extras.objectchange",
    "extras.jobresult",
    "extras.joblogentry",
    "extras.objectmetadata",
    "extras.taggeditem",
    "extras.customfield",
]

# Sort models by the order they're generated by generate_test_data (as described approximately by FACTORY_ORDER above)
with open(sys.argv[1], "r") as input_file:
    input_data = json.load(input_file)


# Regroup the records from a flat list of instances to a nested dict regrouped_data[model][pk] = {data}
regrouped_data = {}

for record in input_data:
    model = record.pop("model")
    pk = record.pop("pk")
    regrouped_data.setdefault(model, {})[pk] = record["fields"]

# Then reorder the regrouped data by creation order and by timestamp
final_data = {}

for model in sorted(regrouped_data.keys(), key=FACTORY_ORDER.index):
    final_data[model] = {}
    # Sort records within a model by created timestamp, or if not applicable, by PK.
    for pk, fields in sorted(regrouped_data[model].items(), key=lambda tup: tup[1].get("created", tup[0])):
        fields.pop("created", None)
        fields.pop("last_updated", None)
        final_data[model][pk] = fields

with open(sys.argv[2], "w") as output_file:
    json.dump(final_data, output_file, sort_keys=False, indent=2)
