# NautobotUIViewSet

New in Nautobot 1.4 is the debut of `NautobotUIViewSet`: A powerful app development tool that can save app developer hundreds of lines of code compared to using legacy `generic.views`. Using it to gain access to default functionalities previous provided by `generic.views` such as `create()`, `update()`, `partial_update()`, `bulk_update()`, `destroy()`, `bulk_destroy()`, `retrieve()` and `list()` actions.

Note that this ViewSet is catered specifically to the UI, not the API.

Concrete examples on how to use `NautobotUIViewSet` resides in `nautobot.circuits.views`.

Below we provide an example on how to use `NautobotUIViewSet` on a theoretical app model.

```python
from nautobot.apps.views import NautobotUIViewSet
from yourapp import filters, forms, models, tables
from yourapp.api import serializers

class YourAppModelUIViewSet(NautobotUIViewSet):
    bulk_update_form_class = forms.YourAppModelBulkEditForm
    filterset_class = filters.YourAppModelFilterSet
    filterset_form_class = forms.YourAppModelFilterForm
    form_class = forms.YourAppModelForm
    queryset = models.YourAppModel.objects.all()
    serializer_class = serializers.YourAppModelSerializer
    table_class = tables.YourAppModelTable
```

## UI Component Framework

The Nautobot UI Component Framework is a system for building user interfaces in Nautobot Apps.
Each ViewSet defines how queries are handled, the layout of panels,
and the organization of content.
Panels are the building blocks of the UI and they contain specific types of content
and can be placed in sections.
The UI Component Framework uses a declarative method that lets developers create UI
structures with Python objects instead of HTML templates.
This method simplifies the process of creating consistent and maintainable user interfaces.
The framework provides many pre-built panel types.

| [Migration tutorial](../../migration/ui-component-framework/index.md)

| [UI Component Framework documentation](../../../../development/core/ui-component-framework.md)

## Setting ViewSet Attributes

**One caveat of using the NautobotUIViewSet is that the `queryset`, `serializer_class` and `table_class` attribute of the `YourAppModelUIViewSet` has to be set before most of the `NautobotUIViewSet` functionalities will become available.**

By default the URL patterns generated by a `NautobotUIViewSet` are based on the model's `pk` (`/model-name/<pk>/` for the detail view, `/model-name/<pk>/edit/` for the edit view, etc.). if you need to use a different field to look up an object, just override the default `lookup_field` in your ViewSet attributes:

```python
from nautobot.apps.views import NautobotUIViewSet

class YourAppModelUIViewSet(NautobotUIViewSet):
    ...
    lookup_field = "slug"
    ...
```

+/- 2.0.0
    The default `lookup_field` for `NautobotUIViewSet` has been changed from `"slug"` to `"pk"`.

!!! note
    Using a field other than the default `pk` or the alternative field `slug` (as shown in the example above), may result in certain pieces of the UI not displaying (for example, the edit and delete buttons on the object detail view). This is due to the URL expecting a named key of slug or pk, rather than id.

## View Template Context

Templates can benefit from a very rich context passed down from the views and renderer, including forms, tables, as well as any other information that may be helpful for rendering templates. The keys it provides are as follows:

* `content_type`: The ContentType object for the associated model
* `filter_form`: The FilterForm object for the associated model
* `form`: A Form object for the associated model if relevant (`None` for list and detail/retrieve views)
* `object`: An instance of the associated mode if available (`None` for list and bulk operation views)
* `permissions`: Summary of user permissions for the given model
* `return_url`: The relevant return URL
* `table`: A Table object for the associated model if relevant (`None` for detail/retrieve and update views)
* `table_config_form`: A TableConfigForm object for the associated `table`, providing the ability to customize the table
* `verbose_name`: The singular form of the model's name
* `verbose_name_plural`: The plural form of the model's name
* `model`: The model class associated for given view
* `view_action`: Current request action
* `detail`: Boolean indicating whether request has given instance or not

An example from editing a Provider object:

```python
{
    'content_type': <ContentType: circuits | provider>,
    'filter_form': <ProviderFilterForm bound=True, valid=Unknown, fields=(location;q;asn;tag)>,
    'form': <ProviderForm bound=False, valid=Unknown, fields=(name;asn;account;portal_url;noc_contact;admin_contact;comments;tags;object_note)>,
    'object': <Provider: NautobotProvider>,
    'permissions': {'add': True, 'change': True, 'delete': True, 'view': True},
    'return_url': '/circuits/providers/nautobotprovider',
    'table': None,
    'table_config_form': None,
    'verbose_name': 'provider',
    'verbose_name_plural': 'providers',
    'model': <Provider>,
    'view_action': 'retrieve',
    'detail': True,
}
```

Other context keys may be available for certain views:

* `editing`: Provided for create and update views to help the template determine if this is a new or existing object
* `action_buttons`: Provided for the list view for the top of table buttons (such as "Add" and "Export")

You may see other context keys as well, but any not documented above should not be relied upon as they may be removed in a future release. Some examples of those are:

* `obj`: Please use `object` instead
* `obj_type`: Please use `verbose_name` instead
* `obj_type_plural`: Please use `verbose_name_plural` instead

--- 2.0.0
    The `changelog_url` context key was removed. Use `object.get_changelog_url` instead.

## Excluding ViewMixins from NautobotUIViewSet

For app models that do not require certain views, simply inherit directly from the `ViewMixin` classes available in `nautobot.apps.views` instead of `NautobotUIViewSet`.

Concrete examples for excluding `ViewMixins`, checkout `CircuitTerminationUIViewSet` and `CircuitTypeUIViewSet` in `nautobot.circuits.views`.

```python
## An app model viewset that does not support bulk views and operations
import nautobot.apps.views

class YourAppModelUIViewSet(
    nautobot.apps.views.ObjectListViewMixin,
    nautobot.apps.views.ObjectDetailViewMixin,
    nautobot.apps.views.ObjectEditViewMixin,
    nautobot.apps.views.ObjectDestroyViewMixin,
):

    filterset_class = YourAppModelFilterSet
    filterset_form_class = YourAppModelFilterForm
    form_class = YourAppModelForm
    queryset = YourAppModel.objects.all()
    serializer_class = serializers.YourAppModelSerializer
    table_class = YourAppModelTable
    # You do not need to specify attributes that are not needed.
```

Excluding unwanted urls from `NautobotUIViewSetRouter` is done for you at the ViewSet level. If you do not inherit the unwanted ViewMixins, the corresponding route from the router will not be published.

```python
# urls.py
# All the urls correspond to BulkViewMixins will not be published when you register your ViewSet with the router.
router.register("yourappmodel", views.YourAppModelUIViewSet)
```

## Template Naming for NautobotUIViewSet

Template naming is very intuitive in NautobotUIViewSet. In `templates/yourapp` folder, name your templates following the convention `{model_name}_{action}.html`.

| ViewMixins                 | action       |
| -------------------------- |:------------:|
| ObjectListViewMixin        | list         |
| ObjectDetailViewMixin      | retrieve     |
| ObjectEditViewMixin        | create/update|
| ObjectDestroyViewMixin     | destroy      |
| ObjectBulkDestroyViewMixin | bulk_destroy |
| ObjectBulkUpdateViewMixin  | bulk_update  |

--- 2.2.0
    ObjectBulkCreateViewMixin is deprecated as its functionality has been replaced by a system Job. It will be removed from the code base entirely in Nautobot 3.0.

For example, for a DetailView template for `YourAppModel`, the template name will be `yourapp/yourappmodel_retrieve.html`, for a BulkUpdateView template for `yourappmodel`, the template name will be `yourapp/yourappmodel_bulk_update.html` and etc.

If you do not provide your own templates in the `yourapp/templates/yourapp` folder, `NautobotUIViewSet` will fall back to `generic/object_{self.action}.html`.

Since in many cases the `create` and `update` templates for a model will be identical, you are not required to create both. If you provide a `{app_label}/{model_opts.model_name}_create.html` file but not a `{app_label}/{model_opts.model_name}_update.html` file, then when you update an object, it will fall back to `{app_label}/{model_opts.model_name}_create.html` and vice versa.

## Adding Custom Views To NautobotUIViewSet & NautobotUIViewSetRouter

Django REST Framework provides the ability to decorate a method on a ViewSet with `@action(detail=True)` to add the method as a view to the ViewSetRouter. This method must return a fully rendered HTML view.

Below is an example of adding a custom action view to an App's UIViewSet. A few considerations to keep in mind:

* The method name is the `action` in Django REST Framework terms.
* The `action` will be used for [template lookup](#template-naming-for-nautobotuiviewset)
* The `action` will be used for URL naming and construction (`plugins:<app>:<model>_<action>`, `/plugins/<app>/<model>/<uuid>/<action>/`).
* The `action` will be used as a custom permission that users must have (`<app>.<action>_<model>`)
    * This default permission (which is often undesirable) can be overridden by specifying `custom_view_base_action` and/or `custom_view_additional_permissions` as parameters to the `action()` decorator. See [below](#overriding-permissions-for-custom-actions) for examples of overriding the default permission.

In the following example:

* The expected template must be named `yourapp/yourappmodel_custom_action.html`
* The reversible URL name will be `plugins:yourapp:yourappmodel_custom_action`
* The URL pattern will be `/plugins/yourapp/yourappmodel/<uuid>/custom_action/`
    * Since Nautobot's convention for URL patterns is to use dashes rather than underscores, you may want to add `url_path="custom-action"` to the `@action()` call, as shown in later examples in this document.
* Users will need `yourapp.custom_action_yourappmodel` permission (or, put another way, the `custom_action` action permission for `yourapp.yourappmodel` records) to access this view.
    * Again, keep reading if you want to use standard `view`/`change`/`create`/`delete` permissions for custom actions instead.

```python
class YourAppModelUIViewSet(NautobotUIViewSet):
    # ...

    @action(detail=True)
    def custom_action(self, request, *args, **kwargs):
        """Perform some custom action on a given YourAppModel record."""
        # Context passed to template for rendering.
        context = {
            "some_key": "some value",
        }
        return Response(context)
```

### Overriding Permissions for Custom Actions

In most cases, custom view actions should not require the creation of custom ObjectPermission definitions to grant access to them, but should instead make use of existing permissions. In these cases, you should use the `custom_view_base_action` parameter (and optionally `custom_view_additional_permissions` as well, if more than a single permission should apply) when declaring the action. Examples follow:

```python title="Require dcim.change_virtualchassis permission rather than dcim.add_member_virtualchassis"
class VirtualChassisUIViewSet:
    # ...

    @action(
        detail=True,
        methods=["get", "post"],
        url_path="add-member",
        url_name="add_member",
        custom_view_base_action="change",
    )
    def add_member(self, request, pk=None):
        # ...
```

```python title="Require both dcim.view_devicetype and dcim.view_interfacetemplate permissions"
class DeviceTypeUIViewSet:
    # ...

    @action(
        detail=True,
        methods=["get"],
        custom_view_base_action="view",
        custom_view_additional_permissions=["dcim.view_interfacetemplate"],
    )
    def interfaces(self, request, *args, **kwargs):
        # ...
```
