# Generated by Django 4.2.19 on 2025-03-10 20:47

import contextlib

from django.db import connection, migrations

from nautobot.core.utils.migrations import migrate_content_type_references_to_new_model


def update_data_validation_engine_job_module_name(apps, schema_editor):
    """
    Update the `module_name` for the Jobs to match the new location of the data validation engine.
    """
    Job = apps.get_model("extras", "Job")
    dve_jobs = Job.objects.filter(module_name="nautobot_data_validation_engine.jobs")
    dve_jobs.update(module_name="nautobot.data_validation.jobs")


def update_data_validation_engine_git_repo_contents(apps, schema_editor):
    """
    Update the `provided_contents` for Git repositories to match the new location of the data validation engine.
    """
    GitRepository = apps.get_model("extras", "gitrepository")
    for repo in GitRepository.objects.all():
        if "nautobot_data_validation_engine.data_compliance_rules" in repo.provided_contents:
            repo.provided_contents.remove("nautobot_data_validation_engine.data_compliance_rules")
            repo.provided_contents.append("data_validation.data_compliance_rule")
            repo.save()


def copy_app_data_to_core_data(apps, schema_editor):
    """
    Some explanation is in order here.

    When we ingested the Nautobot Data Validation Engine app into Nautobot core, we discovered that its autogenerated
    table names for several models were running right up against (but just within) MySQL's 64-character limit for
    identifiers. This would have been a case of :this-is-fine:, but we also discovered that:

    1. Models with a `PositiveIntegerField` (or similar) cause Django to add an *unnamed* CHECK CONSTRAINT to the table
       containing such a field, which delegates the generation of a name to the underlying database itself.
       (This differs from most other cases in Django where it's smart enough to construct a shortened table, field,
       or constraint name to pass through explicitly to the database. An issue reporting this limitation in Django,
       https://code.djangoproject.com/ticket/33169, was closed as invalid/working-as-intended.)
    2. Both MySQL and Dolt, if given an unnamed CHECK CONSTRAINT, will attempt to autogenerate an appropriate name,
       based on the name of the table containing the constraint, but are *not* smart enough to shorten the name
       if necessary, instead outright throwing an error if the generated name is too long.
    3. Dolt's algorithm for autogenerating constraint names is more verbose than MySQL's, meaning that a table name
       and resulting constraint name that _just barely_ fits in MySQL will overflow on Dolt.
       (https://github.com/dolthub/dolt/issues/9099 - This too was closed as working-as-intended.)

    TL;DR: if we want the Data Validation Engine models to work with Dolt, we *must* use a shorter table name than the
    standalone app had defined, and so we cannot "simply" inline the existing table names into Nautobot core.

    Additionally, because we want to avoid the scenario where a user has both Nautobot 3.x and the separate
    Data Validation Engine app installed and active at the same time, we have written a system check that will prevent
    Nautobot 3.x from starting up if the app is enabled in settings.PLUGINS. Therefore this data migration cannot
    have access to the Django ORM models for the app, which is why we're doing the data copying below with direct
    SQL calls instead.
    """
    ContentType = apps.get_model("contenttypes", "ContentType")
    table_names = schema_editor.connection.introspection.table_names()

    if "nautobot_data_validation_engine_minmaxvalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine MinMaxValidationRule records...")
        schema_editor.execute(
            "INSERT INTO data_validation_minmaxrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, min, max) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, min, max "
            "FROM nautobot_data_validation_engine_minmaxvalidationrule;"
        )
        with contextlib.suppress(ContentType.DoesNotExist):
            old_ct = ContentType.objects.get(app_label="nautobot_data_validation_engine", model="minmaxvalidationrule")
            new_ct = ContentType.objects.get_for_model(apps.get_model("data_validation", "minmaxvalidationrule"))
            migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        schema_editor.execute("DELETE FROM nautobot_data_validation_engine_minmaxvalidationrule;")

    if "nautobot_data_validation_engine_regularexpressionvalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine RegularExpressionValidationRule records...")
        schema_editor.execute(
            "INSERT INTO data_validation_regexrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, regular_expression, context_processing) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, regular_expression, context_processing "
            "FROM nautobot_data_validation_engine_regularexpressionvalidationrule;"
        )
        with contextlib.suppress(ContentType.DoesNotExist):
            old_ct = ContentType.objects.get(
                app_label="nautobot_data_validation_engine", model="regularexpressionvalidationrule"
            )
            new_ct = ContentType.objects.get_for_model(
                apps.get_model("data_validation", "regularexpressionvalidationrule")
            )
            migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        schema_editor.execute("DELETE FROM nautobot_data_validation_engine_regularexpressionvalidationrule;")

    if "nautobot_data_validation_engine_requiredvalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine RequiredValidationRule records...")
        schema_editor.execute(
            "INSERT INTO data_validation_requiredrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message "
            "FROM nautobot_data_validation_engine_requiredvalidationrule;"
        )
        with contextlib.suppress(ContentType.DoesNotExist):
            old_ct = ContentType.objects.get(
                app_label="nautobot_data_validation_engine", model="requiredvalidationrule"
            )
            new_ct = ContentType.objects.get_for_model(apps.get_model("data_validation", "requiredvalidationrule"))
            migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        schema_editor.execute("DELETE FROM nautobot_data_validation_engine_requiredvalidationrule;")

    if "nautobot_data_validation_engine_uniquevalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine UniqueValidationRule records...")
        schema_editor.execute(
            "INSERT INTO data_validation_uniquerule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, max_instances) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, max_instances "
            "FROM nautobot_data_validation_engine_uniquevalidationrule;"
        )
        with contextlib.suppress(ContentType.DoesNotExist):
            old_ct = ContentType.objects.get(app_label="nautobot_data_validation_engine", model="uniquevalidationrule")
            new_ct = ContentType.objects.get_for_model(apps.get_model("data_validation", "uniquevalidationrule"))
            migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        schema_editor.execute("DELETE FROM nautobot_data_validation_engine_uniquevalidationrule;")

    if "nautobot_data_validation_engine_datacompliance" in table_names:
        print("  Migrating Nautobot Data Validation Engine DataCompliance records...")
        schema_editor.execute(
            f"""\
INSERT INTO data_validation_datacompliance (
    id,
    created,
    last_updated,
    _custom_field_data,
    compliance_class_name,
    last_validation_date,
    content_type_id,
    object_id,
    validated_object_str,
    validated_attribute,
    validated_attribute_value,
    valid,
    message
) SELECT
    id,
    created,
    last_updated,
    _custom_field_data,
    compliance_class_name,
    last_validation_date,
    content_type_id,
    {"object_id::uuid" if connection.vendor == "postgresql" else "object_id"},
    validated_object_str,
    validated_attribute,
    validated_attribute_value,
    valid,
    message
FROM nautobot_data_validation_engine_datacompliance;"""  # noqa: S608
        )
        with contextlib.suppress(ContentType.DoesNotExist):
            old_ct = ContentType.objects.get(app_label="nautobot_data_validation_engine", model="datacompliance")
            new_ct = ContentType.objects.get_for_model(apps.get_model("data_validation", "datacompliance"))
            migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        schema_editor.execute("DELETE FROM nautobot_data_validation_engine_datacompliance;")


def revert_data_validation_engine_job_module_name(apps, schema_editor):
    """
    Revert the `module_name` for the Jobs to match the old location of the data validation engine.
    """
    Job = apps.get_model("extras", "Job")
    dve_jobs = Job.objects.filter(module_name="nautobot.data_validation.jobs")
    dve_jobs.update(module_name="nautobot_data_validation_engine.jobs")


def revert_data_validation_engine_git_repo_contents(apps, schema_editor):
    """
    Update the `provided_contents` for Git repositories to match the old location of the data validation engine.
    """
    GitRepository = apps.get_model("extras", "gitrepository")
    for repo in GitRepository.objects.all():
        if "data_validation.data_compliance_rule" in repo.provided_contents:
            repo.provided_contents.remove("data_validation.data_compliance_rule")
            repo.provided_contents.append("nautobot_data_validation_engine.data_compliance_rules")
            repo.save()


def copy_core_data_to_app_data(apps, schema_editor):
    ContentType = apps.get_model("contenttypes", "ContentType")
    table_names = schema_editor.connection.introspection.table_names()

    if "nautobot_data_validation_engine_minmaxvalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine MinMaxValidationRule records...")
        schema_editor.execute(
            "INSERT INTO nautobot_data_validation_engine_minmaxvalidationrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, min, max) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, min, max "
            "FROM data_validation_minmaxrule;"
        )
        new_ct, _ = ContentType.objects.get_or_create(
            app_label="nautobot_data_validation_engine", model="minmaxvalidationrule"
        )
        MinMaxValidationRule = apps.get_model("data_validation", "minmaxvalidationrule")
        old_ct = ContentType.objects.get_for_model(MinMaxValidationRule)
        migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        MinMaxValidationRule.objects.all().delete()

    if "nautobot_data_validation_engine_regularexpressionvalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine RegularExpressionValidationRule records...")
        schema_editor.execute(
            "INSERT INTO nautobot_data_validation_engine_regularexpressionvalidationrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, regular_expression, context_processing) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, regular_expression, context_processing "
            "FROM data_validation_regexrule;"
        )
        new_ct, _ = ContentType.objects.get_or_create(
            app_label="nautobot_data_validation_engine", model="regularexpressionvalidationrule"
        )
        RegularExpressionValidationRule = apps.get_model("data_validation", "regularexpressionvalidationrule")
        old_ct = ContentType.objects.get_for_model(RegularExpressionValidationRule)
        migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        RegularExpressionValidationRule.objects.all().delete()

    if "nautobot_data_validation_engine_requiredvalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine RequiredValidationRule records...")
        schema_editor.execute(
            "INSERT INTO nautobot_data_validation_engine_requiredvalidationrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message "
            "FROM data_validation_requiredrule;"
        )
        new_ct, _ = ContentType.objects.get_or_create(
            app_label="nautobot_data_validation_engine", model="requiredvalidationrule"
        )
        RequiredValidationRule = apps.get_model("data_validation", "requiredvalidationrule")
        old_ct = ContentType.objects.get_for_model(RequiredValidationRule)
        migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        RequiredValidationRule.objects.all().delete()

    if "nautobot_data_validation_engine_uniquevalidationrule" in table_names:
        print("  Migrating Nautobot Data Validation Engine UniqueValidationRule records...")
        schema_editor.execute(
            "INSERT INTO nautobot_data_validation_engine_uniquevalidationrule "
            "(id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, max_instances) "
            "SELECT id, created, last_updated, _custom_field_data, "
            "name, field, content_type_id, enabled, error_message, max_instances "
            "FROM data_validation_uniquerule;"
        )
        new_ct, _ = ContentType.objects.get_or_create(
            app_label="nautobot_data_validation_engine", model="uniquevalidationrule"
        )
        UniqueValidationRule = apps.get_model("data_validation", "uniquevalidationrule")
        old_ct = ContentType.objects.get_for_model(UniqueValidationRule)
        migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        UniqueValidationRule.objects.all().delete()

    if "nautobot_data_validation_engine_datacompliance" in table_names:
        print("  Migrating Nautobot Data Validation Engine DataCompliance records...")
        schema_editor.execute(
            f"""\
INSERT INTO nautobot_data_validation_engine_datacompliance (
    id,
    created,
    last_updated,
    _custom_field_data,
    compliance_class_name,
    last_validation_date,
    content_type_id,
    object_id,
    validated_object_str,
    validated_attribute,
    validated_attribute_value,
    valid,
    message
) SELECT
    id,
    created,
    last_updated,
    _custom_field_data,
    compliance_class_name,
    last_validation_date,
    content_type_id,
    {"object_id::char(255)" if connection.vendor == "postgresql" else "object_id"},
    validated_object_str,
    validated_attribute,
    validated_attribute_value,
    valid,
    message
FROM data_validation_datacompliance;"""  # noqa: S608
        )
        new_ct, _ = ContentType.objects.get_or_create(
            app_label="nautobot_data_validation_engine", model="datacompliance"
        )
        DataCompliance = apps.get_model("data_validation", "datacompliance")
        old_ct = ContentType.objects.get_for_model(DataCompliance)
        migrate_content_type_references_to_new_model(apps, old_ct, new_ct)
        DataCompliance.objects.all().delete()


class Migration(migrations.Migration):
    dependencies = [
        ("contenttypes", "0002_remove_content_type_name"),
        ("data_validation", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(
            update_data_validation_engine_job_module_name,
            revert_data_validation_engine_job_module_name,
        ),
        migrations.RunPython(
            update_data_validation_engine_git_repo_contents,
            revert_data_validation_engine_git_repo_contents,
        ),
        migrations.RunPython(
            copy_app_data_to_core_data,
            copy_core_data_to_app_data,
            # required on MySQL to avoid error: "Executing DDL statements while in a transaction
            # on databases that can't perform a rollback is prohibited"
            atomic=False,
        ),
    ]
